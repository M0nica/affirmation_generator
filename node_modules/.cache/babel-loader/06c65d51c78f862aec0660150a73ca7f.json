{"ast":null,"code":"'use strict';\n\nvar nanomatch = require('nanomatch');\n\nvar extglob = require('extglob');\n\nmodule.exports = function (snapdragon) {\n  var compilers = snapdragon.compiler.compilers;\n  var opts = snapdragon.options; // register nanomatch compilers\n\n  snapdragon.use(nanomatch.compilers); // get references to some specific nanomatch compilers before they\n  // are overridden by the extglob and/or custom compilers\n\n  var escape = compilers.escape;\n  var qmark = compilers.qmark;\n  var slash = compilers.slash;\n  var star = compilers.star;\n  var text = compilers.text;\n  var plus = compilers.plus;\n  var dot = compilers.dot; // register extglob compilers or escape exglobs if disabled\n\n  if (opts.extglob === false || opts.noext === true) {\n    snapdragon.compiler.use(escapeExtglobs);\n  } else {\n    snapdragon.use(extglob.compilers);\n  }\n\n  snapdragon.use(function () {\n    this.options.star = this.options.star || function ()\n    /*node*/\n    {\n      return '[^\\\\\\\\/]*?';\n    };\n  }); // custom micromatch compilers\n\n  snapdragon.compiler // reset referenced compiler\n  .set('dot', dot).set('escape', escape).set('plus', plus).set('slash', slash).set('qmark', qmark).set('star', star).set('text', text);\n};\n\nfunction escapeExtglobs(compiler) {\n  compiler.set('paren', function (node) {\n    var val = '';\n    visit(node, function (tok) {\n      if (tok.val) val += (/^\\W/.test(tok.val) ? '\\\\' : '') + tok.val;\n    });\n    return this.emit(val, node);\n  });\n  /**\n   * Visit `node` with the given `fn`\n   */\n\n  function visit(node, fn) {\n    return node.nodes ? mapVisit(node.nodes, fn) : fn(node);\n  }\n  /**\n   * Map visit over array of `nodes`.\n   */\n\n\n  function mapVisit(nodes, fn) {\n    var len = nodes.length;\n    var idx = -1;\n\n    while (++idx < len) {\n      visit(nodes[idx], fn);\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"script"}