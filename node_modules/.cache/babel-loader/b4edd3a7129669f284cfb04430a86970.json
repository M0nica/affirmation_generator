{"ast":null,"code":"'use strict';\n\nvar use = require('use');\n\nvar define = require('define-property');\n\nvar debug = require('debug')('snapdragon:compiler');\n\nvar utils = require('./utils');\n/**\n * Create a new `Compiler` with the given `options`.\n * @param {Object} `options`\n */\n\n\nfunction Compiler(options, state) {\n  debug('initializing', __filename);\n  this.options = utils.extend({\n    source: 'string'\n  }, options);\n  this.state = state || {};\n  this.compilers = {};\n  this.output = '';\n  this.set('eos', function (node) {\n    return this.emit(node.val, node);\n  });\n  this.set('noop', function (node) {\n    return this.emit(node.val, node);\n  });\n  this.set('bos', function (node) {\n    return this.emit(node.val, node);\n  });\n  use(this);\n}\n/**\n * Prototype methods\n */\n\n\nCompiler.prototype = {\n  /**\n   * Throw an error message with details including the cursor position.\n   * @param {String} `msg` Message to use in the Error.\n   */\n  error: function (msg, node) {\n    var pos = node.position || {\n      start: {\n        column: 0\n      }\n    };\n    var message = this.options.source + ' column:' + pos.start.column + ': ' + msg;\n    var err = new Error(message);\n    err.reason = msg;\n    err.column = pos.start.column;\n    err.source = this.pattern;\n\n    if (this.options.silent) {\n      this.errors.push(err);\n    } else {\n      throw err;\n    }\n  },\n\n  /**\n   * Define a non-enumberable property on the `Compiler` instance.\n   *\n   * ```js\n   * compiler.define('foo', 'bar');\n   * ```\n   * @name .define\n   * @param {String} `key` propery name\n   * @param {any} `val` property value\n   * @return {Object} Returns the Compiler instance for chaining.\n   * @api public\n   */\n  define: function (key, val) {\n    define(this, key, val);\n    return this;\n  },\n\n  /**\n   * Emit `node.val`\n   */\n  emit: function (str, node) {\n    this.output += str;\n    return str;\n  },\n\n  /**\n   * Add a compiler `fn` with the given `name`\n   */\n  set: function (name, fn) {\n    this.compilers[name] = fn;\n    return this;\n  },\n\n  /**\n   * Get compiler `name`.\n   */\n  get: function (name) {\n    return this.compilers[name];\n  },\n\n  /**\n   * Get the previous AST node.\n   */\n  prev: function (n) {\n    return this.ast.nodes[this.idx - (n || 1)] || {\n      type: 'bos',\n      val: ''\n    };\n  },\n\n  /**\n   * Get the next AST node.\n   */\n  next: function (n) {\n    return this.ast.nodes[this.idx + (n || 1)] || {\n      type: 'eos',\n      val: ''\n    };\n  },\n\n  /**\n   * Visit `node`.\n   */\n  visit: function (node, nodes, i) {\n    var fn = this.compilers[node.type];\n    this.idx = i;\n\n    if (typeof fn !== 'function') {\n      throw this.error('compiler \"' + node.type + '\" is not registered', node);\n    }\n\n    return fn.call(this, node, nodes, i);\n  },\n\n  /**\n   * Map visit over array of `nodes`.\n   */\n  mapVisit: function (nodes) {\n    if (!Array.isArray(nodes)) {\n      throw new TypeError('expected an array');\n    }\n\n    var len = nodes.length;\n    var idx = -1;\n\n    while (++idx < len) {\n      this.visit(nodes[idx], nodes, idx);\n    }\n\n    return this;\n  },\n\n  /**\n   * Compile `ast`.\n   */\n  compile: function (ast, options) {\n    var opts = utils.extend({}, this.options, options);\n    this.ast = ast;\n    this.parsingErrors = this.ast.errors;\n    this.output = ''; // source map support\n\n    if (opts.sourcemap) {\n      var sourcemaps = require('./source-maps');\n\n      sourcemaps(this);\n      this.mapVisit(this.ast.nodes);\n      this.applySourceMaps();\n      this.map = opts.sourcemap === 'generator' ? this.map : this.map.toJSON();\n      return this;\n    }\n\n    this.mapVisit(this.ast.nodes);\n    return this;\n  }\n};\n/**\n * Expose `Compiler`\n */\n\nmodule.exports = Compiler;","map":null,"metadata":{},"sourceType":"script"}